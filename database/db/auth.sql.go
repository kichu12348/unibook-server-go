// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: auth.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createForumHead = `-- name: CreateForumHead :one
INSERT INTO forum_heads (
  user_id, forum_id, is_verified
) VALUES (
  $1, $2, false
)
RETURNING user_id, forum_id, is_verified
`

type CreateForumHeadParams struct {
	UserID  uuid.UUID `json:"user_id"`
	ForumID uuid.UUID `json:"forum_id"`
}

// Create an entry in the forum_heads join table
func (q *Queries) CreateForumHead(ctx context.Context, arg CreateForumHeadParams) (ForumHead, error) {
	row := q.db.QueryRow(ctx, createForumHead, arg.UserID, arg.ForumID)
	var i ForumHead
	err := row.Scan(&i.UserID, &i.ForumID, &i.IsVerified)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  full_name, email, password_hash, role, college_id, approval_status
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING id, full_name, email, password_hash, role, created_at, approval_status, is_email_verified, email_verification_token, email_verification_expires, password_reset_token, password_reset_expires, college_id
`

type CreateUserParams struct {
	FullName       string         `json:"full_name"`
	Email          string         `json:"email"`
	PasswordHash   string         `json:"password_hash"`
	Role           UserRole       `json:"role"`
	CollegeID      uuid.UUID      `json:"college_id"`
	ApprovalStatus ApprovalStatus `json:"approval_status"`
}

// Insert a new user into the database
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.FullName,
		arg.Email,
		arg.PasswordHash,
		arg.Role,
		arg.CollegeID,
		arg.ApprovalStatus,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.CreatedAt,
		&i.ApprovalStatus,
		&i.IsEmailVerified,
		&i.EmailVerificationToken,
		&i.EmailVerificationExpires,
		&i.PasswordResetToken,
		&i.PasswordResetExpires,
		&i.CollegeID,
	)
	return i, err
}

const getCollegeByID = `-- name: GetCollegeByID :one
SELECT id, name, domain_name, has_paid, created_at, updated_at FROM colleges
WHERE id = $1 LIMIT 1
`

// Get college details to validate the email domain
func (q *Queries) GetCollegeByID(ctx context.Context, id uuid.UUID) (College, error) {
	row := q.db.QueryRow(ctx, getCollegeByID, id)
	var i College
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DomainName,
		&i.HasPaid,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSuperAdminByEmail = `-- name: GetSuperAdminByEmail :one
SELECT id, full_name, email, password_hash, created_at FROM super_admins
WHERE email = $1 LIMIT 1
`

// Fetches a super admin for login verification
func (q *Queries) GetSuperAdminByEmail(ctx context.Context, email string) (SuperAdmin, error) {
	row := q.db.QueryRow(ctx, getSuperAdminByEmail, email)
	var i SuperAdmin
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}

const getSuperAdminByID = `-- name: GetSuperAdminByID :one
SELECT id, full_name, email, password_hash, created_at FROM super_admins WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSuperAdminByID(ctx context.Context, id uuid.UUID) (SuperAdmin, error) {
	row := q.db.QueryRow(ctx, getSuperAdminByID, id)
	var i SuperAdmin
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, full_name, email, password_hash, role, created_at, approval_status, is_email_verified, email_verification_token, email_verification_expires, password_reset_token, password_reset_expires, college_id FROM users
WHERE email = $1 LIMIT 1
`

// Check if a user with a given email already exists
func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.CreatedAt,
		&i.ApprovalStatus,
		&i.IsEmailVerified,
		&i.EmailVerificationToken,
		&i.EmailVerificationExpires,
		&i.PasswordResetToken,
		&i.PasswordResetExpires,
		&i.CollegeID,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT 
    "users"."id" AS "id",
    "users"."full_name" AS "fullName",
    "users"."email" AS "email",
    "users"."role" AS "role",
    "users"."college_id" AS "collegeId",
    "users"."approval_status" AS "approvalStatus",
    "users"."is_email_verified" AS "isEmailVerified",
    "users"."created_at" AS "createdAt",
    -- This is the only line that has changed
    COALESCE("users_college"."data", 'null'::json) AS "college",
    "users_forum_heads"."data" AS "forumHeads"
FROM "users" "users"
LEFT JOIN LATERAL (
    SELECT 
        json_build_object(
            'id', "users_college"."id",
            'name', "users_college"."name"
        )::json AS "data"
    FROM (
        SELECT id, name, domain_name, has_paid, created_at, updated_at FROM "colleges" "users_college"
        WHERE "users_college"."id" = "users"."college_id"
        LIMIT 1
    ) "users_college"
) "users_college" ON TRUE
LEFT JOIN LATERAL (
    SELECT 
        COALESCE(
            json_agg(
                json_build_object(
                    'forumId', "users_forum_heads"."forum_id",
                    'isVerified', "users_forum_heads"."is_verified",
                    'forum', "users_forum_heads_forum"."data"
                )
            ),
            '[]'::json
        ) AS "data"
    FROM "forum_heads" "users_forum_heads"
    
    LEFT JOIN LATERAL (
        SELECT 
            json_build_object(
                'name', "users_forum_heads_forum"."name"
            )::json AS "data"
        FROM (
            SELECT id, name, description, created_at, college_id FROM "forums" "users_forum_heads_forum"
            WHERE "users_forum_heads_forum"."id" = "users_forum_heads"."forum_id"
            LIMIT 1
        ) "users_forum_heads_forum"
    ) "users_forum_heads_forum" ON TRUE
    
    WHERE "users_forum_heads"."user_id" = "users"."id"
) "users_forum_heads" ON TRUE

WHERE "users"."id" = $1
LIMIT 1
`

type GetUserByIDRow struct {
	ID              uuid.UUID        `json:"id"`
	FullName        string           `json:"fullName"`
	Email           string           `json:"email"`
	Role            UserRole         `json:"role"`
	CollegeId       uuid.UUID        `json:"collegeId"`
	ApprovalStatus  ApprovalStatus   `json:"approvalStatus"`
	IsEmailVerified bool             `json:"isEmailVerified"`
	CreatedAt       pgtype.Timestamp `json:"createdAt"`
	College         []byte           `json:"college"`
	ForumHeads      interface{}      `json:"forumHeads"`
}

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.Role,
		&i.CollegeId,
		&i.ApprovalStatus,
		&i.IsEmailVerified,
		&i.CreatedAt,
		&i.College,
		&i.ForumHeads,
	)
	return i, err
}

const setUserEmailVerificationDetails = `-- name: SetUserEmailVerificationDetails :exec
UPDATE users
SET 
  email_verification_token = $2,
  email_verification_expires = $3
WHERE id = $1
`

type SetUserEmailVerificationDetailsParams struct {
	ID                       uuid.UUID        `json:"id"`
	EmailVerificationToken   pgtype.Text      `json:"email_verification_token"`
	EmailVerificationExpires pgtype.Timestamp `json:"email_verification_expires"`
}

// Sets the OTP token and expiration for a user after registration
func (q *Queries) SetUserEmailVerificationDetails(ctx context.Context, arg SetUserEmailVerificationDetailsParams) error {
	_, err := q.db.Exec(ctx, setUserEmailVerificationDetails, arg.ID, arg.EmailVerificationToken, arg.EmailVerificationExpires)
	return err
}

const setUserPasswordResetDetails = `-- name: SetUserPasswordResetDetails :exec
UPDATE users
SET
  password_reset_token=$2,
  password_reset_expires=$3
WHERE id=$1
`

type SetUserPasswordResetDetailsParams struct {
	ID                   uuid.UUID        `json:"id"`
	PasswordResetToken   pgtype.Text      `json:"password_reset_token"`
	PasswordResetExpires pgtype.Timestamp `json:"password_reset_expires"`
}

// Sets the user password reset token
func (q *Queries) SetUserPasswordResetDetails(ctx context.Context, arg SetUserPasswordResetDetailsParams) error {
	_, err := q.db.Exec(ctx, setUserPasswordResetDetails, arg.ID, arg.PasswordResetToken, arg.PasswordResetExpires)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
SET
  password_hash=$2,
  password_reset_expires=NULL,
  password_reset_token=NULL
WHERE id=$1
`

type UpdateUserPasswordParams struct {
	ID           uuid.UUID `json:"id"`
	PasswordHash string    `json:"password_hash"`
}

// Sets the new hashed password for user after reseting
func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.ID, arg.PasswordHash)
	return err
}

const verifyUserEmail = `-- name: VerifyUserEmail :one
UPDATE users
SET
  is_email_verified = true,
  email_verification_token = NULL,
  email_verification_expires = NULL
WHERE id = $1
RETURNING id, full_name, email, password_hash, role, created_at, approval_status, is_email_verified, email_verification_token, email_verification_expires, password_reset_token, password_reset_expires, college_id
`

// Marks a user's email as verified and clears the token fields
func (q *Queries) VerifyUserEmail(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, verifyUserEmail, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.CreatedAt,
		&i.ApprovalStatus,
		&i.IsEmailVerified,
		&i.EmailVerificationToken,
		&i.EmailVerificationExpires,
		&i.PasswordResetToken,
		&i.PasswordResetExpires,
		&i.CollegeID,
	)
	return i, err
}
