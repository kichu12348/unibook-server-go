// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: auth.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createForumHead = `-- name: CreateForumHead :one
INSERT INTO forum_heads (
  user_id, forum_id, is_verified
) VALUES (
  $1, $2, false
)
RETURNING user_id, forum_id, is_verified
`

type CreateForumHeadParams struct {
	UserID  uuid.UUID `json:"user_id"`
	ForumID uuid.UUID `json:"forum_id"`
}

// Create an entry in the forum_heads join table
func (q *Queries) CreateForumHead(ctx context.Context, arg CreateForumHeadParams) (ForumHead, error) {
	row := q.db.QueryRow(ctx, createForumHead, arg.UserID, arg.ForumID)
	var i ForumHead
	err := row.Scan(&i.UserID, &i.ForumID, &i.IsVerified)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  full_name, email, password_hash, role, college_id, approval_status
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING id, full_name, email, password_hash, role, created_at, approval_status, is_email_verified, email_verification_token, email_verification_expires, password_reset_token, password_reset_expires, college_id
`

type CreateUserParams struct {
	FullName       string         `json:"full_name"`
	Email          string         `json:"email"`
	PasswordHash   string         `json:"password_hash"`
	Role           UserRole       `json:"role"`
	CollegeID      uuid.UUID      `json:"college_id"`
	ApprovalStatus ApprovalStatus `json:"approval_status"`
}

// Insert a new user into the database
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.FullName,
		arg.Email,
		arg.PasswordHash,
		arg.Role,
		arg.CollegeID,
		arg.ApprovalStatus,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.CreatedAt,
		&i.ApprovalStatus,
		&i.IsEmailVerified,
		&i.EmailVerificationToken,
		&i.EmailVerificationExpires,
		&i.PasswordResetToken,
		&i.PasswordResetExpires,
		&i.CollegeID,
	)
	return i, err
}

const getCollegeByID = `-- name: GetCollegeByID :one
SELECT id, name, domain_name, has_paid, created_at, updated_at FROM colleges
WHERE id = $1 LIMIT 1
`

// Get college details to validate the email domain
func (q *Queries) GetCollegeByID(ctx context.Context, id uuid.UUID) (College, error) {
	row := q.db.QueryRow(ctx, getCollegeByID, id)
	var i College
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DomainName,
		&i.HasPaid,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSuperAdminByEmail = `-- name: GetSuperAdminByEmail :one
SELECT id, full_name, email, password_hash, created_at FROM super_admins
WHERE email = $1 LIMIT 1
`

// Fetches a super admin for login verification
func (q *Queries) GetSuperAdminByEmail(ctx context.Context, email string) (SuperAdmin, error) {
	row := q.db.QueryRow(ctx, getSuperAdminByEmail, email)
	var i SuperAdmin
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}

const getSuperAdminByID = `-- name: GetSuperAdminByID :one
SELECT id, full_name, email, password_hash, created_at FROM super_admins WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSuperAdminByID(ctx context.Context, id uuid.UUID) (SuperAdmin, error) {
	row := q.db.QueryRow(ctx, getSuperAdminByID, id)
	var i SuperAdmin
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, full_name, email, password_hash, role, created_at, approval_status, is_email_verified, email_verification_token, email_verification_expires, password_reset_token, password_reset_expires, college_id FROM users
WHERE email = $1 LIMIT 1
`

// Check if a user with a given email already exists
func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.CreatedAt,
		&i.ApprovalStatus,
		&i.IsEmailVerified,
		&i.EmailVerificationToken,
		&i.EmailVerificationExpires,
		&i.PasswordResetToken,
		&i.PasswordResetExpires,
		&i.CollegeID,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT
  u.id,
  u.full_name AS "fullName",
  u.email,
  u.role,
  u.college_id AS "collegeId",
  u.approval_status AS "approvalStatus",
  u.is_email_verified AS "isEmailVerified",
  u.created_at AS "createdAt",

  json_build_object(
    'id', c.id,
    'name', c.name
  ) AS college,

  COALESCE(
    json_agg(
      json_build_object(
        'forumId', fh.forum_id,
        'isVerified', fh.is_verified,
        'forum', json_build_object('name', f.name)
      )
    ) FILTER (WHERE fh.user_id IS NOT NULL),
    '[]'::json
  ) AS forum_heads
FROM
  "users" AS u
LEFT JOIN "colleges" AS c ON u.college_id = c.id
LEFT JOIN "forum_heads" AS fh ON u.id = fh.user_id
LEFT JOIN "forums" AS f ON fh.forum_id = f.id
WHERE
  u.id = $1
GROUP BY
  u.id, c.id
LIMIT 1
`

type GetUserByIDRow struct {
	ID              uuid.UUID        `json:"id"`
	FullName        string           `json:"fullName"`
	Email           string           `json:"email"`
	Role            UserRole         `json:"role"`
	CollegeId       uuid.UUID        `json:"collegeId"`
	ApprovalStatus  ApprovalStatus   `json:"approvalStatus"`
	IsEmailVerified bool             `json:"isEmailVerified"`
	CreatedAt       pgtype.Timestamp `json:"createdAt"`
	College         []byte           `json:"college"`
	ForumHeads      interface{}      `json:"forum_heads"`
}

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.Role,
		&i.CollegeId,
		&i.ApprovalStatus,
		&i.IsEmailVerified,
		&i.CreatedAt,
		&i.College,
		&i.ForumHeads,
	)
	return i, err
}

const setUserEmailVerificationDetails = `-- name: SetUserEmailVerificationDetails :exec
UPDATE users
SET 
  email_verification_token = $2,
  email_verification_expires = $3
WHERE id = $1
`

type SetUserEmailVerificationDetailsParams struct {
	ID                       uuid.UUID        `json:"id"`
	EmailVerificationToken   pgtype.Text      `json:"email_verification_token"`
	EmailVerificationExpires pgtype.Timestamp `json:"email_verification_expires"`
}

// Sets the OTP token and expiration for a user after registration
func (q *Queries) SetUserEmailVerificationDetails(ctx context.Context, arg SetUserEmailVerificationDetailsParams) error {
	_, err := q.db.Exec(ctx, setUserEmailVerificationDetails, arg.ID, arg.EmailVerificationToken, arg.EmailVerificationExpires)
	return err
}

const setUserPasswordResetDetails = `-- name: SetUserPasswordResetDetails :exec
UPDATE users
SET
  password_reset_token=$2,
  password_reset_expires=$3
WHERE id=$1
`

type SetUserPasswordResetDetailsParams struct {
	ID                   uuid.UUID        `json:"id"`
	PasswordResetToken   pgtype.Text      `json:"password_reset_token"`
	PasswordResetExpires pgtype.Timestamp `json:"password_reset_expires"`
}

// Sets the user password reset token
func (q *Queries) SetUserPasswordResetDetails(ctx context.Context, arg SetUserPasswordResetDetailsParams) error {
	_, err := q.db.Exec(ctx, setUserPasswordResetDetails, arg.ID, arg.PasswordResetToken, arg.PasswordResetExpires)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
SET
  password_hash=$2,
  password_reset_expires=NULL,
  password_reset_token=NULL
WHERE id=$1
`

type UpdateUserPasswordParams struct {
	ID           uuid.UUID `json:"id"`
	PasswordHash string    `json:"password_hash"`
}

// Sets the new hashed password for user after reseting
func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.ID, arg.PasswordHash)
	return err
}

const verifyUserEmail = `-- name: VerifyUserEmail :one
UPDATE users
SET
  is_email_verified = true,
  email_verification_token = NULL,
  email_verification_expires = NULL
WHERE id = $1
RETURNING id, full_name, email, password_hash, role, created_at, approval_status, is_email_verified, email_verification_token, email_verification_expires, password_reset_token, password_reset_expires, college_id
`

// Marks a user's email as verified and clears the token fields
func (q *Queries) VerifyUserEmail(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, verifyUserEmail, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.CreatedAt,
		&i.ApprovalStatus,
		&i.IsEmailVerified,
		&i.EmailVerificationToken,
		&i.EmailVerificationExpires,
		&i.PasswordResetToken,
		&i.PasswordResetExpires,
		&i.CollegeID,
	)
	return i, err
}
